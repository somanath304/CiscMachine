
import Components.MAR_class;
import Components.pc_class;
import Components.Register;
import Components.IX;
import Components.CC;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

import javax.swing.JOptionPane;
import java.util.concurrent.TimeUnit ;
import java.lang.*;
import java.util.stream.*;
import java.util.Arrays;



public class Frame1 extends javax.swing.JFrame {
pc_class PC=new pc_class();


MAR_class MAR=new MAR_class();
Register R0=new Register();
Register R1=new Register();
Register R2=new Register();
Register R3=new Register();
IX IndexReg1=new IX();
IX IndexReg2=new IX();
IX IndexReg3=new IX();
CC CC0=new CC();
CC CC1=new CC();
CC CC2=new CC();
CC CC3=new CC();
String[] Memory_array=new String[2048];

String MBR="0";
String IR="";

String programfile;

String para="";
String search="";
String s="";
boolean S_result;

int counter_for_input=1;

boolean halt=false;

    /**
     * Creates new form Frame1
     */
    public Frame1() {
        initComponents();
        
        
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        PC_TextField = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        IPL_button = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        Instruction_TextArea = new javax.swing.JTextArea();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        Logger_Textfield = new javax.swing.JTextArea();
        Logger = new javax.swing.JLabel();
        Single_Step_button = new javax.swing.JButton();
        MBR_TextField = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        IR_Textfield = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        Reg0_TextField = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        Reg1_Textfield = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        Reg2_TextField = new javax.swing.JTextField();
        jLabel9 = new javax.swing.JLabel();
        Reg3_TextField = new javax.swing.JTextField();
        IX1_Textfield = new javax.swing.JTextField();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        IX2_TextField = new javax.swing.JTextField();
        jLabel12 = new javax.swing.JLabel();
        IX3_Textfield = new javax.swing.JTextField();
        Execute_Button = new javax.swing.JButton();
        MAR_Textfield = new javax.swing.JTextField();
        jScrollPane3 = new javax.swing.JScrollPane();
        Console_Printer = new javax.swing.JTextArea();
        jLabel13 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        PC_TextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PC_TextFieldActionPerformed(evt);
            }
        });

        jLabel1.setText("PC");

        IPL_button.setText("IPL");
        IPL_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                IPL_buttonActionPerformed(evt);
            }
        });

        Instruction_TextArea.setColumns(15);
        Instruction_TextArea.setRows(5);
        Instruction_TextArea.setAutoscrolls(false);
        jScrollPane1.setViewportView(Instruction_TextArea);

        jLabel2.setText("Instructions(preloaded)");

        jLabel3.setText("MAR");

        Logger_Textfield.setColumns(20);
        Logger_Textfield.setRows(5);
        jScrollPane2.setViewportView(Logger_Textfield);

        Logger.setText("Logger");

        Single_Step_button.setText("Single Step");
        Single_Step_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Single_Step_buttonActionPerformed(evt);
            }
        });

        jLabel4.setText("MBR");

        IR_Textfield.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                IR_TextfieldActionPerformed(evt);
            }
        });

        jLabel5.setText("IR");

        jLabel6.setText("R0");

        jLabel7.setText("R1");

        jLabel8.setText("R2");

        jLabel9.setText("R3");

        Reg3_TextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Reg3_TextFieldActionPerformed(evt);
            }
        });

        jLabel10.setText("Index Reg1");

        jLabel11.setText("Index Reg2");

        jLabel12.setText("Index Reg3");

        Execute_Button.setText("Execute");
        Execute_Button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Execute_ButtonActionPerformed(evt);
            }
        });

        Console_Printer.setColumns(8);
        Console_Printer.setRows(5);
        Console_Printer.setTabSize(6);
        Console_Printer.setAutoscrolls(false);
        jScrollPane3.setViewportView(Console_Printer);

        jLabel13.setText("CONSOLE PRINTER");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(15, 15, 15)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(Single_Step_button, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(IPL_button, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 74, Short.MAX_VALUE)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 489, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(35, 35, 35))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(Execute_Button, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(220, 598, Short.MAX_VALUE))))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(1, 1, 1)
                                .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel3))
                        .addGap(26, 26, 26)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(MBR_TextField, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
                            .addComponent(PC_TextField)
                            .addComponent(MAR_Textfield))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(155, 155, 155)
                                .addComponent(jLabel5)
                                .addGap(35, 35, 35)
                                .addComponent(IR_Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(245, 245, 245)
                                .addComponent(Logger)))
                        .addGap(0, 215, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel6, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel8, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel9, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel7, javax.swing.GroupLayout.Alignment.TRAILING))
                        .addGap(53, 53, 53)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(Reg3_TextField, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
                            .addComponent(Reg0_TextField)
                            .addComponent(Reg2_TextField)
                            .addComponent(Reg1_Textfield))
                        .addGap(132, 132, 132)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addComponent(jLabel12)
                                .addGap(45, 45, 45)
                                .addComponent(IX3_Textfield, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel11)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addComponent(jLabel10)
                                        .addGap(45, 45, 45)))
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(IX2_TextField, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
                                    .addComponent(IX1_Textfield)))
                            .addComponent(jScrollPane1))
                        .addContainerGap())))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel2)
                .addGap(134, 134, 134)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel13)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(35, 35, 35))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(28, 28, 28)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(PC_TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5)
                    .addComponent(IR_Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addGap(11, 11, 11)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(Logger))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(15, 15, 15)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel3)
                            .addComponent(MAR_Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(3, 3, 3)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(14, 14, 14))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(31, 31, 31)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(MBR_TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel4))
                                .addGap(46, 46, 46)
                                .addComponent(Single_Step_button)
                                .addGap(34, 34, 34)
                                .addComponent(IPL_button)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 116, Short.MAX_VALUE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(Reg0_TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel6))
                                .addGap(41, 41, 41)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel7)
                            .addComponent(Reg1_Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 9, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel10)
                            .addComponent(IX1_Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(31, 31, 31)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(IX2_TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel11)))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(Reg2_TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel8))
                                .addGap(25, 25, 25)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(28, 28, 28)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(IX3_Textfield, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel12))
                                .addContainerGap())
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(Reg3_TextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel9))
                                .addGap(20, 20, 20))))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(34, 34, 34)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(2, 2, 2)
                                .addComponent(Execute_Button))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel13)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jScrollPane3)))
                        .addContainerGap())))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void PC_TextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PC_TextFieldActionPerformed
        // TODO add your handling code here:
        
        
        
        
    }//GEN-LAST:event_PC_TextFieldActionPerformed

    private void IPL_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_IPL_buttonActionPerformed
        // TODO add your handling code here:
        
        programfile="Program2.txt";
        String Instr_start;
        //Select which Program to run
        //String programChoice = JOptionPane.showInputDialog("Select Program to Run. Enter 1 or 2");
        //if(programChoice=="1"){
            //programfile="Program1.txt";
            //Instr_start = "100";
        //}
        //else if(programChoice=="2") {
            //programfile="Program2.txt";
            Instr_start = "1000";
        //}
        
        //Initialize PC to first instruction address
        
        PC_TextField.setText(Instr_start);
        PC.value=Integer.parseInt(Instr_start);
        
        //Initialize MAR and MBR 
        MAR_Textfield.setText(""+MAR.value);
        MBR_TextField.setText("0");
        
        //Initialize General Purpose Registers and Index Registers
        Reg0_TextField.setText("0");
        Reg1_Textfield.setText("0");
        Reg2_TextField.setText("0");
        Reg3_TextField.setText("0");
        
        IX1_Textfield.setText("0");
        IX2_TextField.setText("0");
        IX3_Textfield.setText("0");
        
        //Load instructions from file into Memory
        File file = new File(programfile);
        try {
            Scanner s = new Scanner(file);
            int indexInArray = Integer.parseInt(Instr_start);
            int m=Integer.parseInt(Instr_start);
            while (s.hasNextLine()) {
                //System.out.println(s.nextLine());
                String instruction = s.nextLine();
                //System.out.println(instruction);

                Memory_array[indexInArray++] = instruction;
                Instruction_TextArea.append(""+Memory_array[m]+"\n");
                m++;
            }
        } catch (FileNotFoundException e){
            System.out.println(e);
        }
            
        
        if (programfile=="Program1.txt"){
            //Initial Data Stored in Memory
            Memory_array[20]="50"; //Start of input values
            Memory_array[21]="70"; //Location of the search value
            Memory_array[22]="166"; //Start of instructions to perform the search
            Memory_array[23]="50"; //Start of input values - to be used for incrementation
        }
        
        else if (programfile=="Program2.txt") {
            //Initial Data Stored in Memory
            Memory_array[10]="500"; //Input character address for EA
            Memory_array[11]="500"; //Start if input characters
            Memory_array[12]="950"; //Star of search word
            Memory_array[13]="950"; //Search character address for EA
            Memory_array[14]="70046"; //Value of final period
            Memory_array[15]="10000"; //Static line divisor
            Memory_array[16]="1000"; //Static word divisor
            Memory_array[17]=""; //Line # result
            Memory_array[18]=""; //Word # result
            Memory_array[19]=""; //Working character value (cleaned)
            Memory_array[20]="32"; //Space reference
            
            Memory_array[25]="1000"; //Start of Intake instructions, for IX1
            Memory_array[26]="1038"; //Start of Comparison instructions, for IX2
            Memory_array[27]="1070"; //Start of Conclusion Instructios, for IX3
            
            //Read paragrapm text from file into memory            
            System.out.println("Program 2 paragraph text:\n");
            System.out.println("----------------\n");
            
            file = new File("Program2_Text.txt");
            try {
                Scanner s = new Scanner(file);
                while (s.hasNextLine()) {
                    //System.out.println(s.nextLine());
                    String input = s.nextLine();
                    System.out.println(input);
                    Logger_Textfield.append(input+"\n");
                    
                    para = para + input;
                    }
            } catch (FileNotFoundException e){
                System.out.println(e);
                }
            Logger_Textfield.append("-----------------------------\n");
            System.out.println("----------------\n");
            counter_for_input = 0;

            char[] charArray = para.toCharArray();
            int ascii[]=new int[charArray.length];
            for (int i=0;i<charArray.length;i++) 
            {
                ascii[i]=(int)charArray[i];

            }


            int temp[]=new int[charArray.length];
            int tenthousand=10000;
            int thousand=0;
            int f=0;

            for (int i=0;i<charArray.length-1;i++) 
            {

                if(ascii[i]==32){
                thousand=thousand+1000;
                }
                if(ascii[i]==46){
                thousand=0;   
                tenthousand=tenthousand+10000;

                }

                temp[f]=ascii[i];
                temp[f]=temp[f]+tenthousand+thousand;


                f++;
            }

            for(int x=0,val=Integer.parseInt(Memory_array[11]); x<temp.length-1; x++, val++){

            Memory_array[val]=String.valueOf(temp[x]);
            }
        }
        
        //Log of Initialization
        Logger_Textfield.append("System is initiated and ready\n");
        Logger_Textfield.append("PC was loaded with first instruction address: "+PC.value+"\n");
        Logger_Textfield.append("MAR was initiated with address: "+MAR.value+"\n");
        Logger_Textfield.append("MBR was initiated with value: "+MBR+"\n");
        Logger_Textfield.append("-----------------------------\n");
        Logger_Textfield.append("Press Execute or Single Step to continue execution\n");
        Logger_Textfield.append("-----------------------------\n");
        
    }//GEN-LAST:event_IPL_buttonActionPerformed

    private void MAR_TextfieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MAR_TextfieldActionPerformed
        // TODO add your handling code here:
        
    }//GEN-LAST:event_MAR_TextfieldActionPerformed

    private void Single_Step_buttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Single_Step_buttonActionPerformed
        // TODO add your handling code here:
        
        //FETCH PHASE
        Logger_Textfield.append("PC holds instruction address: "+PC.value+"\n");
        Logger_Textfield.append("PERFORM FETCH:\n");
        MAR.value=PC.value;
        MAR_Textfield.setText(""+MAR.value);
        Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
        String Instruction=fetch_from_memory(MAR.value);
        
        MBR=Instruction;
        MBR_TextField.setText(MBR);
        Logger_Textfield.append("MBR was set to "+MBR+"\n");
        //helper hel = new helper();
        
        IR=MBR;
        IR_Textfield.setText(IR);
        Logger_Textfield.append("IR was set to "+IR+"\n");
        
        //DECODE INSTRUCTION PHASE
        Logger_Textfield.append("PERFORM DECODE:\n");
        int inst_array[]=new int[5];
        inst_array=parse_instruction_method(IR);
        
        if (halt==false){
            Logger_Textfield.append("Opcode is "+inst_array[0]+"\n");
            Logger_Textfield.append("Register is "+inst_array[1]+"\n");
            Logger_Textfield.append("Index Register is "+inst_array[2]+"\n");
            Logger_Textfield.append("Address is "+inst_array[3]+"\n");
            Logger_Textfield.append("Indirect is "+inst_array[4]+"\n");

            //EXECUTE INSTRUCTION PHASE
            Logger_Textfield.append("PERFORM EXECUTE:\n");
            Execute_Ins(inst_array);
            PC_TextField.setText(String.valueOf(PC.value));
            Logger_Textfield.append("\n-----------------------------\n");
        }
    }//GEN-LAST:event_Single_Step_buttonActionPerformed

    private void IR_TextfieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_IR_TextfieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_IR_TextfieldActionPerformed

    private void Reg3_TextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Reg3_TextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_Reg3_TextFieldActionPerformed

    private void Execute_ButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Execute_ButtonActionPerformed
        // TODO add your handling code here:
        
        
        while (halt==false) {
            //FETCH PHASE
            Logger_Textfield.append("PC holds instruction address: "+PC.value+"\n");
            Logger_Textfield.append("PERFORM FETCH:\n");
            MAR.value=PC.value;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR.value was set to "+MAR.value+"\n");        
            String Instruction=fetch_from_memory(MAR.value);

            MBR=Instruction;
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            //helper hel = new helper();

            IR=MBR;
            IR_Textfield.setText(IR);
            Logger_Textfield.append("IR was set to "+IR+"\n");

            //DECODE INSTRUCTION PHASE
            Logger_Textfield.append("PERFORM DECODE:\n");
            int inst_array[]=new int[5];
            inst_array=parse_instruction_method(IR);
            
            if (halt==false){
                Logger_Textfield.append("Opcode is "+inst_array[0]+"\n");
                Logger_Textfield.append("Register is "+inst_array[1]+"\n");
                Logger_Textfield.append("Index Register is "+inst_array[2]+"\n");
                Logger_Textfield.append("Address  is "+inst_array[3]+"\n");
                Logger_Textfield.append("Indirect is "+inst_array[4]+"\n");

                //EXECUTE INSTRUCTION PHASE
                Logger_Textfield.append("PERFORM EXECUTE:\n");
                Execute_Ins(inst_array);
                PC_TextField.setText(String.valueOf(PC.value));
                Logger_Textfield.append("\n-----------------------------\n");
            }
            
        } 
        
    }//GEN-LAST:event_Execute_ButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        /* Create and display the form */
        
        Frame1 f=new Frame1();
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Frame1().setVisible(true);
                
                
                
                
                
            
            }
        });
    }

    public String fetch_from_memory(int addr) {
        
       String ins=Memory_array[addr];
       // ins was a string fetch from memory
       //Logger_Textfield.append("PERFORM FETCH - Contents of address "+addr+" are "+ins+"\n");
       return ins;
       
        
    }
    
    public int[] parse_instruction_method(String ins) {
            int array_read[]=new int[5];
        String[] split = ins.split(",");
        String operation = split[0];
        int generalReg= Integer.parseInt(split[1]);
        String indexReg = split[2];
        String Indirect_addr_num = split[3];
        String address = split[4];
        //helper hel = new helper();
        
        
        int IndirectBit=Integer.parseInt(Indirect_addr_num);
        int IndexReg=Integer.parseInt(indexReg);
        int Addr = Integer.parseInt(address);
        
//        int[] valueinti = hel.decToBinary(integeri).clone();
//        int[] valueindex = hel.decToBinary(integerindex).clone();
//        int[] valueaddress = hel.decToBinary(integeraddress).clone();
 
        int opcode=0;
        switch(operation) {
            case "LDR":
                
                opcode = 1;
                Logger_Textfield.append("The instruction is 'Load Register from Memory'\n");
                break;
            case "STR":
                
                opcode = 2;
                Logger_Textfield.append("The instruction is 'Store Register to Memory'\n");
                break;
            
            case "LDA":
                
                opcode = 3;
                Logger_Textfield.append("The instruction is 'Load Register with Address'\n");
                break;
                
            case "LDX":
                
                opcode = 41;
                Logger_Textfield.append("The instruction is 'Load Index Register from Memory'\n");
                break;
                    
            case "STX":
                
                opcode = 42;
                Logger_Textfield.append("The instruction is 'Store Index Register to Memory'\n");
                break;
                
            case "JZ":
                
                opcode = 10;
                Logger_Textfield.append("The instruction is 'Jump if zero'\n");
                break;
                
            case "JNE":
                
                opcode = 11;
                Logger_Textfield.append("The instruction is 'Jump if not zero'\n");
                break;
                
            case "JMA":
                
                opcode = 13;
                Logger_Textfield.append("The instruction is 'Jump to Address (unconditional)'\n");
                break;
               
            case "SOB":
                
                opcode = 16;
                Logger_Textfield.append("The instruction is 'Subtract One and Branch'\n");
                break;
                
                
            case "AMR":
                
                opcode = 04;
                Logger_Textfield.append("The instruction is 'Add Memory to Register'\n");
                break;
                
            case "SMR":
                
                opcode = 05;
                Logger_Textfield.append("The instruction is 'Substract Memory from Register'\n");
                break;

            case "SIR":
                
                opcode = 7;
                Logger_Textfield.append("The instruction is 'Substract Immediate from Register'\n");
                break;
                
            case "SRC":
                
                opcode = 31;
                Logger_Textfield.append("The instruction is 'Shift Register by Count'\n");
                break;
                
            case "RRC":
                
                opcode = 32;
                Logger_Textfield.append("The instruction is 'Rotate Register by Count'\n");
                break;
                
             case "JCC":
                
                opcode = 12;
                Logger_Textfield.append("The instruction is 'Jump if condition code'\n");
                break;
                 
             case "JGE":
                
                opcode = 17;
                Logger_Textfield.append("The instruction is 'Jump if greater than equal to '\n");
                break;

            case "TRR":
                opcode = 22;
                Logger_Textfield.append("The instruction is 'Test the equality of two registers'\n");
                break;


            case "AND":
                opcode = 23;
                Logger_Textfield.append("The instruction is 'Logic AND for two registers'\n");
                break;


            case "ORR":
                opcode = 24;
                Logger_Textfield.append("The instruction is 'Logic OR for two resigers'\n");
                break;

            case "NOT":
                opcode = 25;
                Logger_Textfield.append("The instruction is 'Logic NOT of one register'\n");
                break;
                
            case "AIR":
                
                opcode = 6;
                Logger_Textfield.append("The instruction is 'Add Immediate to Register'\n");
                break;
                
            case "MLT":
                opcode = 20;
                Logger_Textfield.append("The instruction is 'Multiply Register by Register'\n");
                break;
                
            case "DVD":
                opcode = 21;
                Logger_Textfield.append("The instruction is 'Divide Register by Register'\n");
                break;

            case "JSR":
                opcode = 14;
                Logger_Textfield.append("The instruction is 'Jump and save return address'\n");
                break;


            case "RFS":
                opcode = 15;
                Logger_Textfield.append("The instruction is 'Return from subroutine with return code'\n");
                break;
                
            case "IN":
                opcode = 61;
                Logger_Textfield.append("The instruction is 'Input character to Register from Device'\n");
                break;
                
            case "OUT":
                opcode = 62;
                Logger_Textfield.append("The instruction is 'Output character to Device from Register'\n");
                break;

                
            case "HLT":
                opcode = 0;
                halt=true;
                
                if (programfile=="Program1.txt"){
                    Logger_Textfield.append("HLT encountered ");
                    Logger_Textfield.append("\n-----------------------------\n");
                    Logger_Textfield.append("CONSOLE OUTPUT\n");
                    Logger_Textfield.append("Search value is: "+R0.value+"\n");
                    Logger_Textfield.append("Input closest to search value: "+Memory_array[10]+"\n");
                    Logger_Textfield.append("Difference from search value: "+Memory_array[11]+"\n");
                    Logger_Textfield.append("-----------------------------\n");
                }
                
                else if (programfile=="Program2.txt") {
                    if (S_result==false) {
                    Logger_Textfield.append("HLT encountered ");
                    Logger_Textfield.append("\n-----------------------------\n");
                    Logger_Textfield.append("Search word not found in the paragraph.\n");
                    }
                    
                    if (S_result==true) {
                    Logger_Textfield.append("HLT encountered ");
                    Logger_Textfield.append("\n-----------------------------\n");
                    Logger_Textfield.append("CONSOLE OUTPUT\n");
                    Logger_Textfield.append("Search word is: "+search+"\n");
                    Logger_Textfield.append("Found at:"+"\n");
                    Logger_Textfield.append("Line number "+Memory_array[17]+"\n");
                    Logger_Textfield.append("Word number "+(Integer.parseInt(Memory_array[18])-1)+"\n");
                    Logger_Textfield.append("-----------------------------\n");
                    JOptionPane.showMessageDialog(null, " Line number "+Memory_array[17]+" Word number "+(Integer.parseInt(Memory_array[18])-1));
                    
                    }
                }
                break;

        }
        
        int reg=0;
        switch(generalReg) {
            
            case 0:
                //Set instruction array as Register 0
                reg = 0;
                break;
            case 1:
                //Set instruction array as Register 1
                reg = 1;
                break;
            case 2:
                //Set instruction array as Register 2
                reg = 2;
                break;
            case 3:
                //Set instruction array as Register 3
                reg = 3;
                break;

        }

//Pull all instruction components into an array to be returned
        array_read[0]=opcode;
       // System.out.print(""+opcode);
        array_read[1]=reg;
        array_read[2]=IndexReg;
        array_read[3]=Addr;
        array_read[4]=IndirectBit;
        
        return array_read;
        
    }
        
    public int effective_address(int IndexReg, int indirect, int address) {
        //Performs Effective Address calculation on the address field
        int EA=address;
        int A;
        
        //Check the Indirect bit
        if (indirect==0){
            A = address;
        }
        else {
            A = Integer.parseInt(Memory_array[address]);
        }
        
        //Check for indexing
        if (IndexReg==0){
            EA = A;
        }
        else {
            switch(IndexReg){
                case 1: //Index Register 1
                    EA = IndexReg1.value + A;
                    break;
                case 2: //Index Register 2
                    EA = IndexReg2.value + A;
                    break;
                case 3: //Index Register 3
                    EA = IndexReg3.value + A;
                    break;
            }
        }
        return EA;
    }

        
    public void Execute_Ins(int temp_array[]) {
        //Pass the instruction array components into values
            int instruct=temp_array[0];
            int address=temp_array[3];
            int register=temp_array[1];
            String value="";
            int IndexReg=temp_array[2];
            int d=register;
            int register2=temp_array[2];
            int indirect=temp_array[4];

                   // System.out.print("INdex reg is"+IndexReg);
                     
        switch(instruct){
        //case for HLT to exit the program
            case 0: HLT();break;

        // case for LDR Load Register from Memory
            case 1: LDR(register,value,address,IndexReg,indirect);break;
               
        // case for STR Store Register To Memory
            case 2: STR(register,value,address,IndexReg,indirect);break;
                           
        //case for LDA Load Register with Address
                case 3: LDA(register,value,address,IndexReg,indirect);break;
                           
        //case for LDX Load Index Register from Memory
                case 41 :  LDX(register,value,address,IndexReg,indirect);break;
                         
        //case for STX Store Index Register to Memory         
                case 42 :  STX(register,value,address,IndexReg,indirect);break;
        
        //case for JZ Jump if Zero
                case 10 :  JZ(register,value,address,IndexReg,indirect);break;
        
        //case for JNE Jump if not zero
                case 11 :  JNE(register,value,address,IndexReg,indirect);break;
        
        //case for JMA Jump to Address
                case 13 :  JMA (value,address,IndexReg,indirect);break;
                        
        //case for SOB Subtract one and branch        
                case 16 :  SOB(register,address,IndexReg,indirect);break;
                
        //case for SRC Shift Register by Count
                case 31 :  SRC(temp_array[1],temp_array[2],temp_array[4],temp_array[3]);break;
                
        //case for RRC Rotate Register by Count
                case 32 :  RRC(temp_array[1],temp_array[2],temp_array[4],temp_array[3]);break;
                
        //case for JCC Jump if Condition Code
                case 12 :  JCC(register,address,IndexReg,indirect);break;
                
        //case for JGE Jump if Greater Than or Equal To
                case 17 : JGE(register,value,address,IndexReg,indirect);break;
                
        //case for AMR Add Memory to Register
                case 4: AMR(register,value,address,IndexReg,indirect);break;
                
        //case for SMR Subtract Memory from Register
                case 5:SMR(register,value,address,IndexReg,indirect);break;
                
        //case for Subtract Immediate from Register
                case 7 : SIR(register,address);break;
                
        //case for AIR Add Immediate to Register
                case 6 : AIR(register,address);break;
                
        //case for MLT Multiply Register by Register
                case 20: MLT(register,IndexReg);break;
                
        //case for DVD Divide Register by Register
                case 21: DVD(register,IndexReg);break;

        //case for JSR Jump and Save Return Address
            case 14: JSR(IndexReg, address, indirect); break;

        //case for RFS Return from Subroutine 
            case 15: RFS(address); break;
            
        //case for IN Input to Register from Device
            case 61: IN(register,address); break;
            
        //case for OUT Output to Device from Register
            case 62: OUT(register); break;

            case 36: TRAP(address); break;

        //case for TRR Test the Equality of Register and Register
            case 22:
                if(register == 0 && IndexReg ==1)
                    TRR(R0,R1,0);
                else if(register == 0 && IndexReg == 2)
                    TRR(R0,R2,0);
                else if(register == 0 && IndexReg == 3)
                    TRR(R0,R3,0);
                else if(register == 1 && IndexReg == 0)
                    TRR(R1,R0,1);
                else if(register == 1 && IndexReg == 2)
                    TRR(R1,R2,1);
                else if(register == 1 && IndexReg == 3)
                    TRR(R1,R3,1);
                else if(register == 2 && IndexReg == 0)
                    TRR(R2,R0,2);
                else if(register == 2 && IndexReg == 1)
                    TRR(R2,R1,2);
                else if(register == 2 && IndexReg == 3)
                    TRR(R2,R3,2);
                else if(register == 3 && IndexReg == 0)
                    TRR(R3,R0,3);
                else if(register == 3 && IndexReg == 1)
                    TRR(R3,R1,3);
                else if(register == 3 && IndexReg == 2)
                    TRR(R3,R2,3);
                break;

        //case for AND Logical And of Register and Register
            case 23:
                if(register == 0 && address ==1)
                    AND(R0,R1,0);
                else if(register == 0 && address == 2)
                    AND(R0,R2,0);
                else if(register == 0 && address == 3)
                    AND(R0,R3,0);
                else if(register == 1 && address == 0)
                    AND(R1,R0,1);
                else if(register == 1 && address == 2)
                    AND(R1,R2,1);
                else if(register == 1 && address == 3)
                    AND(R1,R3,1);
                else if(register == 2 && address == 0)
                    AND(R2,R0,2);
                else if(register == 2 && address == 1)
                    AND(R2,R1,2);
                else if(register == 2 && address == 3)
                    AND(R2,R3,2);
                else if(register == 3 && address == 0)
                    AND(R3,R0,3);
                else if(register == 3 && address == 1)
                    AND(R3,R1,3);
                else if(register == 3 && address == 2)
                    AND(R3,R2,3);


                break;

        //case for ORR Logical Or of Register and Register
            case 24:
                if(register == 0 && address ==1)
                    ORR(R0,R1,0);
                else if(register == 0 && address == 2)
                    ORR(R0,R2,0);
                else if(register == 0 && address == 3)
                    ORR(R0,R3,0);
                else if(register == 1 && address == 0)
                    ORR(R1,R0,1);
                else if(register == 1 && address == 2)
                    ORR(R1,R2,1);
                else if(register == 1 && address == 3)
                    ORR(R1,R3,1);
                else if(register == 2 && address == 0)
                    ORR(R2,R0,2);
                else if(register == 2 && address == 1)
                    ORR(R2,R1,2);
                else if(register == 2 && address == 3)
                    ORR(R2,R3,2);
                else if(register == 3 && address == 0)
                    ORR(R3,R0,3);
                else if(register == 3 && address == 1)
                    ORR(R3,R1,3);
                else if(register == 3 && address == 2)
                    ORR(R3,R2,3);


                break;

        //case for NOT Logical Not of Register to Register
            case 25:
                if(register == 0)
                    NOT(R0,0);

                else if(register == 1 && address == 0)
                    NOT(R1,1);

                else if(register == 2 && address == 0)
                    NOT(R2,2);

                else if(register == 3 && address == 0)
                    NOT(R3,3);

                break;
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextArea Console_Printer;
    private javax.swing.JButton Execute_Button;
    private javax.swing.JButton IPL_button;
    private javax.swing.JTextField IR_Textfield;
    private javax.swing.JTextField IX1_Textfield;
    private javax.swing.JTextField IX2_TextField;
    private javax.swing.JTextField IX3_Textfield;
    private javax.swing.JTextArea Instruction_TextArea;
    private javax.swing.JLabel Logger;
    private javax.swing.JTextArea Logger_Textfield;
    private javax.swing.JTextField MAR_Textfield;
    private javax.swing.JTextField MBR_TextField;
    private javax.swing.JTextField PC_TextField;
    private javax.swing.JTextField Reg0_TextField;
    private javax.swing.JTextField Reg1_Textfield;
    private javax.swing.JTextField Reg2_TextField;
    private javax.swing.JTextField Reg3_TextField;
    private javax.swing.JButton Single_Step_button;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    // End of variables declaration//GEN-END:variables

    public void HLT () {
        int exit = JOptionPane.showConfirmDialog(null, "Program has finished.\nClick YES to view logger or NO to exit:", "Program Halt", 0);
        if (exit==1){System.exit(0);}
        else { return;}
    }

    public void TRAP(int address) {
        PC.value++;
        Memory_array[2] = Integer.toString(PC.getValue());
        int zero_address = Integer.parseInt(Memory_array[0]);
        int new_address = zero_address + address;
        PC.setValue(new_address);
        //Frame1 f = new Frame1();
        int[] int_instruction = parse_instruction_method(Memory_array[new_address]);
        Execute_Ins(int_instruction);
        PC.setValue(Integer.parseInt(Memory_array[2]));
        Logger_Textfield.append("Trap instruction is executed\n");



    }
    
    public void LDR (int register, String value, int address, int IndexReg, int indirect) {
        //Load Register from Memory
        
        //Convert address into Effective Address
        address = effective_address(IndexReg,indirect,address);
        
        if(register==0)//load to resgister 0
        {
            //Get the data from Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Put the data in the Register
            value=Memory_array[address];
            R0.value=Integer.parseInt(value);
            Reg0_TextField.setText(""+R0.value);
            Logger_Textfield.append("Register "+register+" loaded '"+R0.value+"' from memory address "+address+"\n");
        }
        if(register==1)//load to resgister 1
        {
            //Get the data from Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Put the data in the Register
            value=Memory_array[address];
            R1.value=Integer.parseInt(value);
            Reg1_Textfield.setText(""+R1.value);
            Logger_Textfield.append("Register "+register+" loaded '"+R1.value+"' from memory address "+address+"\n");
        }
        if(register==2)//load to resgister 2
        {
            //Get the data from Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Put the data in the Register
            value=Memory_array[address];
            R2.value=Integer.parseInt(value);
            Reg2_TextField.setText(""+R2.value);
            Logger_Textfield.append("Register "+register+" loaded '"+R2.value+"' from memory address "+address+"\n");
        }
        if(register==3)//load to resgister 3
        {
            //Get the data from Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Put the data in the Register
            value=Memory_array[address];
            R3.value=Integer.parseInt(value);
            Reg3_TextField.setText(""+R3.value);
            Logger_Textfield.append("Register "+register+" loaded '"+R3.value+"' from memory address "+address+"\n");
        }
        PC.value++;
    }

    public void STR(int register, String value, int address, int IndexReg, int indirect) {
        //Store Register to Memory
        
        //Convert address to Effective Address
        address = effective_address(IndexReg,indirect,address);
        
        if(register==0){
            //try{}catch (Exception E){}
            //R0.value="200";
            //Reg0_TextField.setText(""+R0.value);
            //TimeUnit.SECONDS.sleep(1);
            //R0.value=String.valueOf(address);
            
            //Set the Memory[address] to be written
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");

            //Get the data from Register
            MBR=String.valueOf(R0.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Store the data in Memory[address]
            Memory_array[address]=MBR;
            Logger_Textfield.append("Memory location "+address+" stored '"+R0.value+"' from Register "+register+"\n");
        }
        if(register==1){
            //R1.value="300";
            //Reg1_Textfield.setText(""+R1.value);
            
            //Set the Memory[address] to be written
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            
            //Get the data from Register
            MBR=String.valueOf(R1.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Store the data in Memory[address]
            Memory_array[address]=MBR;
            Logger_Textfield.append("Memory location "+address+" stored '"+R1.value+"' from Register "+register+"\n");
        }
        if(register==2){
            //R2.value="400";
            //Reg2_TextField.setText(""+R2.value);
            
            //Set the Memory[address] to be written
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            
            //Get the data from Register
            MBR=String.valueOf(R2.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Store the data in Memory[address]
            Memory_array[address]=MBR;
            Logger_Textfield.append("Memory location "+address+" stored '"+R2.value+"' from Register "+register+"\n");
        }
        if(register==3){
            //R3.value="500";
            //Reg3_TextField.setText(""+R3.value);
            
            //Set the Memory[address] to be written
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            
            //Get the data from Register
            MBR=String.valueOf(R3.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Store the data in Memory[address]
            Memory_array[address]=MBR;
            Logger_Textfield.append("Memory location "+address+" stored '"+R3.value+"' from Register "+register+"\n");
        }
        PC.value++;
    }
    
    public void LDA (int register, String value,int address, int IndexReg, int indirect) {
        address = effective_address(IndexReg,indirect,address);
        if(register==0){
            R0.value=address;
            Reg0_TextField.setText(""+R0.value);
            MBR=String.valueOf(R0.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("Register R0.value was loaded with "+address);
        }
        if(register==1){
            R1.value=address;
            Reg1_Textfield.setText(""+R1.value);
            MBR=String.valueOf(R1.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("Register R1.value was loaded with "+address);
        }
        if(register==2){
            R2.value=address;
            Reg2_TextField.setText(""+R2.value);
            MBR=String.valueOf(R2.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("Register R2.value was loaded with "+address);
        }
        if(register==3){
            R3.value=address;
            Reg3_TextField.setText(""+R3.value);
            MBR=String.valueOf(R3.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("Register R3.value was loaded with "+address);
        }
        PC.value++;

    }
    
    public void LDX(int register, String value, int address,int IndexReg, int indirect) {
        //Load Index Register from Memory

        //Convert address to Effective Address
        if (indirect==1){
            address = Integer.parseInt(Memory_array[address]);
        }
        
        if(IndexReg==1){
            //Get the data from Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Put the data in the Index Register
            IndexReg1.value=Integer.parseInt(MBR);
            IX1_Textfield.setText(""+IndexReg1.value);
            Logger_Textfield.append("Index register "+IndexReg+" loaded '"+IndexReg1.value+"' from memory address "+address+"\n");
        }
        if(IndexReg==2){
            //Get the data from Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Put the data in the Index Register
            IndexReg2.value=Integer.parseInt(MBR);
            IX2_TextField.setText(""+IndexReg2.value);
            Logger_Textfield.append("Index register "+IndexReg+" loaded '"+IndexReg2.value+"' from memory address "+address+"\n");
        }
        if(IndexReg==3){
            //Get the data from Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Put the data in the Index Register
            IndexReg3.value=Integer.parseInt(MBR);
            IX3_Textfield.setText(""+IndexReg3.value);
            Logger_Textfield.append("Index register "+IndexReg+" loaded '"+IndexReg3.value+"' from memory address "+address+"\n");
        }
        PC.value++;
    }
    
    public void STX (int register,String value,int address, int IndexReg, int indirect) {
        //Store Index Register to Memory

        //Convert address to Effective Address
        if (indirect==1){
            address = Integer.parseInt(Memory_array[address]);
        }
        
        if(IndexReg==1){
            //Set the Memory[address] to be written
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            
            //Get the data from Index Register
            MBR=String.valueOf(IndexReg1.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Store the data in Memory[address]
            Memory_array[address]=MBR;
            Logger_Textfield.append("Memory location "+address+" stored '"+IndexReg1.value+"' from Index Register "+IndexReg+"\n");
        }
        if(IndexReg==2){
            //Set the Memory[address] to be written
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            
            //Get the data from Index Register
            MBR=String.valueOf(IndexReg2.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Store the data in Memory[address]
            Memory_array[address]=MBR;
            Logger_Textfield.append("Memory location "+address+" stored '"+IndexReg2.value+"' from Index Register "+IndexReg+"\n");
        }
        if(IndexReg==3){
            //Set the Memory[address] to be written
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            
            //Get the data from Index Register
            MBR=String.valueOf(IndexReg3.value);
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Store the data in Memory[address]
            Memory_array[address]=MBR;
            Logger_Textfield.append("Memory location "+address+" stored '"+IndexReg3.value+"' from Index Register "+IndexReg+"\n");
        }
        PC.value++;
    }
    
    public void JZ (int register,String value,int address,int IndexReg, int indirect) {
        
               address = effective_address(IndexReg,indirect,address); 
               if((R0.value==0)&&(register==0)){
                   
                   PC.value=address;
                   Logger_Textfield.append("Register = 0. PC was loaded with jump address "+address+"\n");
                   PC_TextField.setText(""+address);
               }
               else if(((R1.value==0)&&(register==1))){
                   
                   PC.value=address;
                   Logger_Textfield.append("Register = 0. PC was loaded with jump address "+address+"\n");
                   PC_TextField.setText(""+address);
               }
               else if(((R2.value==0)&&(register==2))){
                   
                   PC.value=address;
                   Logger_Textfield.append("Register = 0. PC was loaded with jump address "+address+"\n");
                   PC_TextField.setText(""+address);
               }
               else if(((R3.value==0)&&(register==3))){
                   
                   PC.value=address;
                   Logger_Textfield.append("Register = 0. PC was loaded with jump address "+address+"\n");
                   PC_TextField.setText(""+address);
               }
               
               else{
                   PC.value++;
                   Logger_Textfield.append("Register != 0. PC was loaded with next instruction address "+PC.value);
               }
         
    


}
        public void JNE (int register,String value,int address,int IndexReg, int indirect) {
              address = effective_address(IndexReg,indirect,address);
              if((R0.value!=0)&&(register==0)){
                   
                   PC.value=address;
                   Logger_Textfield.append("Register != 0. PC was loaded with jump address "+address+"\n");
                   PC_TextField.setText(""+address);
               }
              else if((R1.value!=0)&&(register==1)){
                   
                   PC.value=address;
                   Logger_Textfield.append("Register != 0. PC was loaded with jump address "+address+"\n");
                   PC_TextField.setText(""+address);
               }
              else if(((R2.value!=0)&&(register==2))){
                   
                   PC.value=address;
                   Logger_Textfield.append("Register != 0. PC was loaded with jump address "+address+"\n");
                   PC_TextField.setText(""+address);
               }
              else if(((R3.value!=0)&&(register==3))){
                   
                   PC.value=address;
                   Logger_Textfield.append("Register != 0. PC was loaded with jump address "+address+"\n");
                   PC_TextField.setText(""+address);
               }
              else{
                   PC.value++;
                   Logger_Textfield.append("Register = 0. PC was loaded with next instruction address "+PC.value+"\n");
               }
        
        } 
         
 public void JMA (String value,int address,int IndexReg, int indirect) {
    //Jump to Address (Unconditional)
    
    //Convert address into Effective Address
    address = effective_address(IndexReg,indirect,address);
    
    //Set Program Counter to the Effective Address
    PC.value = address;
    PC_TextField.setText(""+PC.value);
    Logger_Textfield.append("PC was loaded with jump address " + PC.value + "\n");
    

}

public void SOB(int register,int address,int IndexReg, int indirect) {
    address = effective_address(IndexReg,indirect,address);
    if(register==0){
        
        //int R0.value = R0.value;
        //System.out.println("oinsde SOB");
        R0.value--;
        Reg0_TextField.setText(""+R0.value);
        if (R0.value > 0) {
            PC.value = address;
            
            PC_TextField.setText(""+PC.value);
            Logger_Textfield.append("Value of R0.value subtracted by 1 , Register "+R0.value+" address moved to PC");
        }
        else {
            PC.value++;
            PC_TextField.setText(""+PC.value);
            Logger_Textfield.append("Value of R0.value subtracted by 1 , Register "+R0.value+" address increased by 1");
        }

    }
    else if (register == 1) {
        //int R1.value = R1.value;

        R1.value--;
        Reg1_Textfield.setText(""+R1.value);
        if (R1.value > 0) {
            PC.value = address;
            PC_TextField.setText(""+PC.value);
            Logger_Textfield.append("Value of R0.value subtracted by 1 , Register "+R1.value+" address moved to PC");
        }
        else {
            PC.value++;
            PC_TextField.setText(""+PC.value);
            Logger_Textfield.append("Value of R0.value subtracted by 1 , Register "+R1.value+" address moved to PC");
        }

    }
    else if (register == 2) {
        //int R2.value = R2.value;

        R2.value--;
        Reg2_TextField.setText(""+R2.value);
        if (R2.value > 0) {
            PC.value = address;
            PC_TextField.setText(""+PC.value);
            Logger_Textfield.append("Value of R0.value subtracted by 1 , Register "+R2.value+" address moved to PC");
        }
        else {
            PC.value++;
            PC_TextField.setText(""+PC.value);
            Logger_Textfield.append("Value of R0.value subtracted by 1 , Register "+R2.value+" address moved to PC");
        }

    }
    else if(register == 3) {
        //int R3.value_value = R3.value;

        R3.value--;
        Reg3_TextField.setText(Integer.toString(R3.value));
        if (R3.value > 0) {
            PC.value = address;
            PC_TextField.setText(""+PC.value);
            Logger_Textfield.append("Value of R0.value subtracted by 1 , Register "+R3.value+" address moved to PC");
        }
        else {
            PC.value++;
            PC_TextField.setText(""+PC.value);
            Logger_Textfield.append("Value of R0.value subtracted by 1 , Register "+R3.value+" address moved to PC");
        }

    }

}
    
    public void SRC(int register, int type, int direction, int count ){
        
        int R_value = 0;
        //Obtain value from the Register
        if (register==0){
            R_value=R0.value;
        }
        
        else if (register==1){
            R_value=R1.value;
        }
        
        else if (register==2){
            R_value=R2.value;
        }
        
        else if (register==3){
            R_value=R3.value;
        }
        
        //Perform the Shift
        StringBuilder start = new StringBuilder(Integer.toBinaryString(R_value));
        int i=start.length();
        while (i<12){
            start.insert(0, "0");
            i++;
        }
        
        Logger_Textfield.append("Starting value in Register is: "+start+"\n");
        Logger_Textfield.append("Count is: "+count+"\n");
        Logger_Textfield.append("Type is: "+type+"\n");
        Logger_Textfield.append("Direction is: "+direction+"\n");
        
        String result="";
                
        if (direction==1){ //Left Shift (Arithmetic and Logical)
            StringBuilder shifted = new StringBuilder(Integer.toBinaryString(R_value<<count));
            i=shifted.length();
            while (i<12){
                shifted.insert(0, "0");
                i++;
            }
            Logger_Textfield.append("Shifted value in Register is: "+shifted+"\n");
            result = shifted.toString();
        }
        
        else { //Right Shift
            
            if (type==0){ //Arithmetic Right
                              
                StringBuilder shifted = new StringBuilder(Integer.toBinaryString(R_value>>count));
                i=shifted.length();
                while (i<12){
                    shifted.insert(0, "0");
                    i++;
                }
                Logger_Textfield.append("Shifted value in Register is: "+shifted+"\n");
                result = shifted.toString();
            }
            
            else if (type==1){//Logical Right
                StringBuilder shifted = new StringBuilder(Integer.toBinaryString(R_value>>>count));
                i=shifted.length();
                while (i<12){
                    shifted.insert(0, "0");
                    i++;
                }
                Logger_Textfield.append("Shifted value in Register is: "+shifted+"\n");
                result = shifted.toString();
            }
        }
        
        //Return output to Register
        if (register==0){
            R0.value=Integer.parseInt(result,2);
            Reg0_TextField.setText(""+R0.value);
        }
        
        else if (register==1){
            R1.value=Integer.parseInt(result,2);
            Reg1_Textfield.setText(""+R1.value);
        }
        
        else if (register==2){
            R2.value=Integer.parseInt(result,2);
            Reg2_TextField.setText(""+R2.value);
        }
        
        else if (register==3){
            R3.value=Integer.parseInt(result,2);
            Reg3_TextField.setText(""+R3.value);
        }

        PC.value++;
        
    }
    
    public void RRC(int register, int type, int direction, int count){
        int R_value = 0;
        //Obtain value from the Register
        if (register==0){
            R_value=R0.value;
        }
        
        else if (register==1){
            R_value=R1.value;
        }
        
        else if (register==2){
            R_value=R2.value;
        }
        
        else if (register==3){
            R_value=R3.value;
        }
        
        //Perform Rotate
        StringBuilder start = new StringBuilder(Integer.toBinaryString(R_value));
        //int len1=start.length();
        int i=start.length();
        while (i<12){
            start.insert(0, "0");
            i++;
        }
        
        Logger_Textfield.append("Starting value in Register is: "+start+"\n");
        Logger_Textfield.append("Count is: "+count+"\n");
        Logger_Textfield.append("Type is: "+type+"\n");
        Logger_Textfield.append("Direction is: "+direction+"\n");
        
        String result="";
        
        if (direction==0){//Right Rotate
            int j = start.length()-count;
            String rotated = start.substring(j)+ start.substring(0,j);
            Logger_Textfield.append("Rotated value in Register is: "+rotated+"\n");
            result = rotated.toString();
        }
        
        else if (direction==1){//Left Rotate
            String rotated = start.substring(count)+start.substring(0,count);
            Logger_Textfield.append("Rotated value in Register is: "+rotated+"\n");
            result = rotated.toString();
        }
        
        //Return output to Register
        if (register==0){
            R0.value=Integer.parseInt(result,2);
            Reg0_TextField.setText(""+R0.value);
        }
        
        else if (register==1){
            R1.value=Integer.parseInt(result,2);
            Reg1_Textfield.setText(""+R1.value);
        }
        
        else if (register==2){
            R2.value=Integer.parseInt(result,2);
            Reg2_TextField.setText(""+R2.value);
        }
        
        else if (register==3){
            R3.value=Integer.parseInt(result,2);
            Reg3_TextField.setText(""+R3.value);
        }
        
        PC.value++;
    }

    
    public void JCC(int register,int address,int IndexReg, int indirect){
    //Jump if Condition Code

    //Convert address into Effective Address
    address = effective_address(IndexReg,indirect,address);
    
    //Set Program Counter based on Control Code bit
    if(register==0){
        Logger_Textfield.append("Control Code bit "+register+" is '"+CC0.value+"'\n");
        
        if(CC0.value==true){
        PC.value=address;
        PC_TextField.setText(""+PC.value);
        Logger_Textfield.append("PC was loaded with address '" + address + "'\n");
        }
        else{
            Logger_Textfield.append("PC was incremented with the next instruction address\n");
            PC.value++;
        }
    }
    
    if(register==1){
        Logger_Textfield.append("Control Code bit "+register+" is '"+CC1.value+"'\n");
        
        if(CC1.value==true){
        PC.value=address;
        PC_TextField.setText(""+PC.value);
        Logger_Textfield.append("PC was loaded with address '" + address + "'\n");
        }
        else{
            Logger_Textfield.append("PC was incremented with the next instruction address\n");
            PC.value++;
        }
    }
    
    if(register==2){
        Logger_Textfield.append("Control Code bit "+register+" is '"+CC2.value+"'\n");
        
        if(CC2.value==true){
        PC.value=address;
        PC_TextField.setText(""+PC.value);
        Logger_Textfield.append("PC was loaded with address '" + address + "'\n");
        }
        else{
            Logger_Textfield.append("PC was incremented with the next instruction address\n");
            PC.value++;
        }
    }
    
    if (register==3){
        Logger_Textfield.append("Control Code bit "+register+" is '"+CC3.value+"'\n");
        
        if(CC3.value==true){
        PC.value=address;
        PC_TextField.setText(""+PC.value);
        Logger_Textfield.append("PC was loaded with address '" + address + "'\n");
        }
        else{
            Logger_Textfield.append("PC was incremented with the next instruction address\n");
            PC.value++;
        }
    }
    
    
    }
    
    public void JGE(int register,String value,int address,int IndexReg, int indirect){
        //Jump if Greater Than or Equal To

        //Convert address into Effective Address
        address = effective_address(IndexReg,indirect,address);

        //Set Program Counter based on Register value greater than or equal to 0
        if(register==0){
           if(R0.value>=0){
               Logger_Textfield.append("Register "+register+" value '"+R0.value+"' is greater than 0\n");
               PC.value=address;
               PC_TextField.setText(""+PC.value);
               Logger_Textfield.append("PC was loaded with address '" + address + "'\n");
           }
           else{
                Logger_Textfield.append("PC was incremented with the next instruction address\n");
                PC.value++;
            }

        }
        if(register==1){
            if(R1.value>=0){
               Logger_Textfield.append("Register "+register+" value '"+R1.value+"' is greater than 0\n");
               PC.value=address;
               PC_TextField.setText(""+PC.value);
               Logger_Textfield.append("PC was loaded with address '" + address + "'\n");
            }
            else{
                Logger_Textfield.append("PC was incremented with the next instruction address\n");
                PC.value++;
            }
        }
        if(register==2){
            if(R2.value>=0){
               Logger_Textfield.append("Register "+register+" value '"+R2.value+"' is greater than 0\n");
               PC.value=address;
               PC_TextField.setText(""+PC.value);
               Logger_Textfield.append("PC was loaded with address '" + address + "'\n");
            }
            else{
                Logger_Textfield.append("PC was incremented with the next instruction address\n");
                PC.value++;
            }
        }
        if(register==3){
            if(R3.value>=0){
               Logger_Textfield.append("Register "+register+" value '"+R3.value+"' is greater than 0\n");
               PC.value=address;
               PC_TextField.setText(""+PC.value);
               Logger_Textfield.append("PC was loaded with address '" + address + "'\n");
            }
            else{
                Logger_Textfield.append("PC was incremented with the next instruction address\n");
                PC.value++;
            }
        }
    
    }
    
   
    

    public void AMR(int register, String value, int address, int IndexReg, int indirect) {
        address = effective_address(IndexReg,indirect,address);
        if(register==0){  
            value=(Memory_array[address]);
            MBR_TextField.setText(""+value);
            R0.value=R0.value+Integer.parseInt(value);
            Reg0_TextField.setText(Integer.toString(R0.value)); 
            Logger_Textfield.append("Register is added with value "+value);

            }  
        
        if(register==1){  
            value=(Memory_array[address]);
            MBR_TextField.setText(""+value);
            R1.value=R1.value+Integer.parseInt(value);
            Reg1_Textfield.setText(Integer.toString(R1.value));     
            Logger_Textfield.append("Register is added with value "+value);
            }  
        
        if(register==2){  
            value=(Memory_array[address]);
            MBR_TextField.setText(""+value);
            R2.value=R2.value+Integer.parseInt(value);
            Reg2_TextField.setText(Integer.toString(R2.value));    
            Logger_Textfield.append("Register is added with value "+value);
            }  
        
        if(register==3){  
            value=(Memory_array[address]);
            MBR_TextField.setText(""+value);
            R3.value=R3.value+Integer.parseInt(value);
            Reg3_TextField.setText(Integer.toString(R3.value));   
            Logger_Textfield.append("Register is added with value "+value);
            }
        PC.value++;
        }
    
      public void SMR(int register, String value, int address, int IndexReg, int indirect) {
        //Subtract Memory from Register

        //Convert address into Effective Address
        address = effective_address(IndexReg,indirect,address);
        
        if(register==0){  
            //Get the contents of Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Subtract the contets of Memory[address] from the Register
            value=(MBR);
            R0.value=R0.value-Integer.parseInt(value);
            Reg0_TextField.setText(Integer.toString(R0.value));
            Logger_Textfield.append("Register "+register+" value changed to '"+R0.value+"'\n");
            }  
        
        if(register==1){  
            //Get the contents of Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Subtract the contets of Memory[address] from the Register
            value=(MBR);
            R1.value=R1.value-Integer.parseInt(value);
            Reg1_Textfield.setText(Integer.toString(R1.value));
            Logger_Textfield.append("Register "+register+" value changed to '"+R1.value+"'\n");
            }  
        
        if(register==2){  
            //Get the contents of Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Subtract the contets of Memory[address] from the Register
            value=(MBR);
            R2.value=R2.value-Integer.parseInt(value);
            Reg2_TextField.setText(Integer.toString(R2.value));
            Logger_Textfield.append("Register "+register+" value changed to '"+R2.value+"'\n");
            }  
        
        if(register==3){  
            //Get the contents of Memory[address]
            MAR.value=address;
            MAR_Textfield.setText(""+MAR.value);
            Logger_Textfield.append("MAR was set to "+MAR.value+"\n");
            MBR=Memory_array[address];
            MBR_TextField.setText(MBR);
            Logger_Textfield.append("MBR was set to "+MBR+"\n");
            
            //Subtract the contets of Memory[address] from the Register
            value=(MBR);
            R3.value=R3.value-Integer.parseInt(value);
            Reg3_TextField.setText(Integer.toString(R3.value));
            Logger_Textfield.append("Register "+register+" value changed to '"+R3.value+"'\n");
            }
        PC.value++;
        }
      
      public void SIR (int register,int address) {
        if(register==0){
            
            R0.value-=address;
            Reg0_TextField.setText(Integer.toString(R0.value));
            Logger_Textfield.append("Value of Register "+register+" was substracted by "+address);
        }
        
         if(register==1){
            R1.value-=address;
            Reg1_Textfield.setText(Integer.toString(R1.value));
            Logger_Textfield.append("Value of Register "+register+" was substracted by "+address);
        }
         
          if(register==2){
            R2.value-=address;
            Reg2_TextField.setText(Integer.toString(R2.value));  
            Logger_Textfield.append("Value of Register "+register+" was substracted by "+address);

        }
          
           if(register==3){
            R3.value-=address;
            Reg3_TextField.setText(Integer.toString(R3.value));
            Logger_Textfield.append("Value of Register "+register+" was substracted by "+address);
        }
    PC.value++;
    }


    public void TRR(Register register1, Register register2,int registerNum) {
        //Test the equality of Register and Register
        
        //If Register X is equal to Register Y, set CC bit to TRUE
        if (register1.getValue() == register2.getValue()) {
            Logger_Textfield.append("Register values '"+register1.getValue()+"' and '"+register2.getValue()+"' are equal\n");
            CC3.setValue(true);
            Logger_Textfield.append("Control Code bit 3 set to 'true' (1)\n");

        }
        
        //IF Register x is not equal to Register Y, set CC bit to FALSE
        else {
            Logger_Textfield.append("Register values '"+register1.getValue()+"' and '"+register2.getValue()+"' are not equal\n");
            CC3.setValue(false);
            Logger_Textfield.append("Control Code bit 3 set to 'false' (0)\n");
        }
        
    PC.value++;
    }

    public void AND (Register registerX, Register registerY,int registerNum) {
        int result = registerX.getValue() & registerY.getValue();
        registerX.setValue(result);
        Logger_Textfield.append("Set value of register " + registerNum + "to be " + result + "\n");

    PC.value++;

    }

    public void ORR(Register registerX, Register registerY,int registerNum) {
        int result = registerX.getValue() | registerY.getValue();
        registerX.setValue(result);
        Logger_Textfield.append("Set value of register" + registerNum +  "to be" + result + "\n");
    PC.value++;
    }

    public void NOT(Register register,int registerNum) {
        //Logical NOT of the Register 
        
        //Perform bitwise Not operation on Register value
        int result = ~register.getValue();
        register.setValue(result);
        Logger_Textfield.append("Set value of register " + registerNum  +  " to '" + result + "'\n");
    PC.value++;
    }

    public void JSR(int IndexReg, int address, int indirect) {
        address = effective_address(IndexReg,indirect,address);
        int toR3 = PC.getValue() + 1;
        R3.setValue(toR3);
        PC.setValue(address);
        Logger_Textfield.append("Assign the PC value plus to R3 and assign immediate value to PC");

    //PC.value++;
    }

    public void RFS(int Immed) {
        R0.setValue(Immed);
        PC.setValue(R3.getValue());
        Logger_Textfield.append("Assign Immediate value to R0 and assign content of R3 to PC");
    //PC.value++;
    }

    public void IN(int register, int address) {
        String inputVariable="";
        if (programfile=="Program1.txt"){
            //Input from Device to Register
            

            //Prompt the user for an input value

            if(address==1){
                inputVariable= JOptionPane.showInputDialog(" Enter a search value to check against");
            }
            else {

                inputVariable= JOptionPane.showInputDialog(" Enter number "+counter_for_input);
                counter_for_input++;
            }
            try 
            { 
                // checking valid integer using parseInt() method 
                Integer.parseInt(inputVariable); 

            }  
            catch (NumberFormatException e)  
            { 

                JOptionPane.showMessageDialog(null, " The number you entered is not a valid integer number");
                inputVariable= JOptionPane.showInputDialog("Enter a new valid integer number ");
            } 

            if (Integer.parseInt(inputVariable)>65535){ //If input value is out of bounds
                    JOptionPane.showMessageDialog(null, "The value you entered is greater than the storage limit");
                    inputVariable= JOptionPane.showInputDialog("Enter a new number less than 65,535: ");
                }

            //Put the input value into the Register
            if (register==0){
                R0.value=Integer.parseInt(inputVariable);
                Logger_Textfield.append("Input value '"+inputVariable+"' from keyboard was entered into Register "+register+"\n");
                Reg0_TextField.setText(Integer.toString(R0.value));
            }

            if (register==1){
                R1.value=Integer.parseInt(inputVariable);
                Logger_Textfield.append("Input value '"+inputVariable+"' from keyboard was entered into Register "+register+"\n");
                Reg1_Textfield.setText(Integer.toString(R1.value));
            }

            if (register==2){
                R2.value=Integer.parseInt(inputVariable);
                Logger_Textfield.append("Input value '"+inputVariable+"' from keyboard was entered into Register "+register+"\n");
                Reg2_TextField.setText(Integer.toString(R2.value));
            }

            if (register==3){
                R3.value=Integer.parseInt(inputVariable);
                Logger_Textfield.append("Input value '"+inputVariable+"' from keyboard was entered into Register "+register+"\n");
                Reg3_TextField.setText(Integer.toString(R3.value));
            }
        }
        
        else if (programfile=="Program2.txt"){
            ///*
            if(address==1){
                inputVariable = JOptionPane.showInputDialog(" Sara has a big brown dog .\n" +
" His name is Max .\n" +
" Max is cute and fluffy and very friendly .\n" +
" He likes going for walks and playing outside .\n" +
" He also likes cuddling on the couch .\n" +
" Max and Sara are very happy living together . \n" + 
"\nEnter a single search word (no spaces) to find in the paragraph \n(Note the search value is case sensitive)");
                
                search = inputVariable;
                inputVariable = " "+inputVariable+" ";
                search = inputVariable;
                S_result=para.contains(search);
                                
                char[] charArray = inputVariable.toCharArray();
                int ascii[]=new int[charArray.length];
                int sum=0;
                
                for (int i=0;i<charArray.length;i++) 
                {
                    ascii[i]=(int)charArray[i];
                    sum = sum + ascii[i];
                }
                  
                //Put the search value into the Register
                if(register==0){
                    R0.value=sum;
                    Logger_Textfield.append("Code for search value '"+search+"' from keyboard was entered into Register "+register+"\n");
                    Reg0_TextField.setText(Integer.toString(R0.value));
                }

                if (register==1){
                    R1.value=sum;
                    Logger_Textfield.append("Code for search value '"+search+"' from keyboard was entered into Register "+register+"\n");
                    Reg1_Textfield.setText(Integer.toString(R1.value));
                }

                if (register==2){
                    R2.value=sum;
                    Logger_Textfield.append("Code for search value '"+search+"' from keyboard was entered into Register "+register+"\n");
                    Reg2_TextField.setText(Integer.toString(R2.value));
                }

                if (register==3){
                    R3.value=sum;
                    Logger_Textfield.append("Code for search value '"+search+"' from keyboard was entered into Register "+register+"\n");
                    Reg3_TextField.setText(Integer.toString(R3.value));
                }
                
            }
            else { //address==0

                char[] charArray = search.toCharArray();
                int ascii[]=new int[charArray.length];
                
                for (int i=0;i<charArray.length;i++) 
                {
                    ascii[i]=(int)charArray[i];
                    
                }
            
                //Put the input value into the Register
                if(register==0){
                    //Assign R0.value to first item in the temporary array; increment a count for the array
                    R0.value=ascii[counter_for_input-1];
                    Logger_Textfield.append("Search character '"+R0.value+"' from search word was entered into Register "+register+"\n");
                    Reg0_TextField.setText(Integer.toString(R0.value));
                }

                if (register==1){
                    R1.value=ascii[counter_for_input];
                    Logger_Textfield.append("Search character '"+R1.value+"' from search word was entered into Register "+register+"\n");
                    Reg1_Textfield.setText(Integer.toString(R1.value));
                }

                if (register==2){
                    R2.value=ascii[counter_for_input];
                    Logger_Textfield.append("Search character '"+R2.value+"' from search word was entered into Register "+register+"\n");
                    Reg2_TextField.setText(Integer.toString(R2.value));
                }

                if (register==3){
                    R3.value=ascii[counter_for_input];
                    Logger_Textfield.append("Search character '"+R3.value+"' from search word was entered into Register "+register+"\n");
                    Reg3_TextField.setText(Integer.toString(R3.value));
                }
            }
            counter_for_input++;
        }
        
    PC.value++;
    }

    public void OUT (int register){
        
        Logger_Textfield.append("Output Register contents to the Console Printer\n");
        
        if (programfile=="Program1.txt"){
            if (register==0){Console_Printer.append(String.valueOf(R0.value)+"\n");}
            if (register==1){Console_Printer.append(String.valueOf(R1.value)+"\n");}
            if (register==2){Console_Printer.append(String.valueOf(R2.value)+"\n");}
            if (register==3){Console_Printer.append(String.valueOf(R3.value)+"\n");}
        }
        
        else if (programfile=="Program2.txt"){
            if (register==0 && R0.value>=32){Console_Printer.append(Character.toString((char)R0.value)+"\n");}
            if (register==0 && R0.value<32){Console_Printer.append(R0.value+"\n");}
            if (register==1 && R1.value>=32){Console_Printer.append(Character.toString((char)R1.value)+"\n");}
            if (register==1 && R1.value<32){Console_Printer.append(R1.value+"\n");}
            if (register==2 && R2.value>=32){Console_Printer.append(Character.toString((char)R2.value)+"\n");}
            if (register==2 && R2.value<32){Console_Printer.append(R2.value+"\n");}
            if (register==3 && R3.value>=32){Console_Printer.append(Character.toString((char)R3.value)+"\n");}
            if (register==3 && R3.value<32){Console_Printer.append(R3.value+"\n");}
        }
        PC.value++;
    }
    
    public void AIR (int register,int address){
        //Add Immediate value to Register
        
        if(register==0){
            R0.value+=address;
            Reg0_TextField.setText(Integer.toString(R0.value));
            Logger_Textfield.append("Register "+register+" value changed to '"+R0.value+"'\n");
        }

        if(register==1){
            R1.value+=address;
            Reg1_Textfield.setText(Integer.toString(R1.value));
            Logger_Textfield.append("Register "+register+" value changed to '"+R1.value+"'\n");
        }

        if(register==2){
            R2.value+=address;
            Reg2_TextField.setText(Integer.toString(R2.value));  
            Logger_Textfield.append("Register "+register+" value changed to '"+R2.value+"'\n");
        }

        if(register==3){
            R3.value+=address;
            Reg3_TextField.setText(Integer.toString(R3.value));
            Logger_Textfield.append("Register "+register+" value changed to '"+R3.value+"'\n");
        }
    PC.value++;
    }
            
    
       public void MLT (int register, int d) {
        if(register==0 && d==2){
            
            int c= R0.value*R2.value;
            if(c<=2147483647)
            {             
                String a = Integer.toBinaryString(c);
                while (a.length() < 32) 
                {    //if length is less than 32 then ) will be added to the string
                   a = "0" + a;
                }
                Reg0_TextField.setText(a.substring(0,16));
                Reg1_Textfield.setText(a.substring(16,32));
                Logger_Textfield.append("Multiplication performed");
            }else{throw new ArithmeticException("Access denied - You must be at least 18 years old.");}   
        }
        
         if(register==2 && d==0){
            
            int c= R2.value*R0.value;
            if(c<=2147483647){
                
                String a = Integer.toBinaryString(c);
                while (a.length() < 32) 
                {    //if length is less than 32 then ) will be added to the string
                   a = "0" + a;
                   }
            Reg2_TextField.setText(a.substring(0,16));
            Reg3_TextField.setText(a.substring(16,32));
            Logger_Textfield.append("Multiplication performed");
             }   
        }
      PC.value++;
      }
    
    public void DVD (int register, int d)
    {
       //Put register values into temporary variables 
       int reg_val=0;
       if (register==0) {reg_val=R0.value; Logger_Textfield.append("Divide R0 value "+R0.value+" by ");}
       if (register==1) {reg_val=R1.value; Logger_Textfield.append("Divide R1 value "+R1.value+" by ");}
       if (register==2) {reg_val=R2.value; Logger_Textfield.append("Divide R2 value "+R2.value+" by ");}
       if (register==3) {reg_val=R3.value; Logger_Textfield.append("Divide R3 value "+R3.value+" by ");}

       int d_val=0;
       if (d==0) {d_val=R0.value; Logger_Textfield.append("R0 value "+R0.value+"\n");}
       if (d==1) {d_val=R1.value; Logger_Textfield.append("R1 value "+R1.value+"\n");}
       if (d==2) {d_val=R2.value; Logger_Textfield.append("R2 value "+R2.value+"\n");}
       if (d==3) {d_val=R3.value; Logger_Textfield.append("R3 value "+R3.value+"\n");}
       
       //Perform division
       int quotient;
       int remainder;
       
       if(d_val==0){throw new ArithmeticException("Condition code 3 Divide by zero");}
       else{
             quotient= reg_val / d_val;
             remainder= reg_val % d_val;
           }
       
       //Put temporary variables back into register values
       if (register==0) {R0.value=quotient; Reg0_TextField.setText(Integer.toString(R0.value));}
       if (register==1) {R1.value=quotient; Reg1_Textfield.setText(Integer.toString(R1.value));}
       if (register==2) {R2.value=quotient; Reg2_TextField.setText(Integer.toString(R2.value));}
       if (register==3) {R3.value=quotient; Reg3_TextField.setText(Integer.toString(R3.value));}

       if (d==0) {R0.value=remainder; Reg0_TextField.setText(Integer.toString(R0.value));}
       if (d==1) {R1.value=remainder; Reg1_Textfield.setText(Integer.toString(R1.value));}
       if (d==2) {R2.value=remainder; Reg2_TextField.setText(Integer.toString(R2.value));}
       if (d==3) {R3.value=remainder; Reg3_TextField.setText(Integer.toString(R3.value));}
       
    PC.value++;
    }
    


}



